<!--
------------------------
    ‚†Ñ‚†Ç‚†Ç‚¢Ç‚†®  ‚≠ë‚òΩ   üîÖ

  –í–æ—Å—Ö–æ–¥ –∏ –∑–∞—Ö–æ–¥ –°–æ–ª–Ω—Ü–∞ –ù–ï–í–û–ó–ú–û–ñ–ù–û –¢–û–ß–ù–û —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å, –∏–∑-–∑–∞
–∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω–æ–π —Ä–µ—Ñ—Ä–∞–∫—Ü–∏–∏, –≤—ã—Å–æ—Ç—ã –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è –∏ —Ä–µ–ª—å–µ—Ñ–∞ –º–µ—Å—Ç–Ω–æ—Å—Ç–∏.
–†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç –∏–º–µ—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—Ç
—Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–≥–æ.
  –ê–≤—Ç–æ—Ä –ø–æ—Å—Ç–∞—Ä–∞–ª—Å—è —É—á–µ—Å—Ç—å –≤—Å–µ —ç—Ç–∏ —Ñ–∞–∫—Ç–æ—Ä—ã –ø–æ –º–µ—Ä–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π:
  -–¥–ª—è —É—á–µ—Ç–∞ —Ä–µ—Ñ—Ä–∞–∫—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π –º–µ—Ç–µ–æ–¥–∞–Ω–Ω—ã–µ.
  -–¥–ª—è —É—á–µ—Ç–∞ –≤—ã—Å–æ—Ç—ã –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è –∏ —Ä–µ–ª—å–µ—Ñ–∞ –Ω–∞–∂–º–∏–Ω–∞ "–ü—Ä–æ—Å—á–∏—Ç–∞—Ç—å
—Å —É—á–µ—Ç–æ–º —Ä–µ–ª—å–µ—Ñ–∞" –∏ —Å–º–æ—Ç—Ä–∏—Ç–µ –≤—Ä–µ–º—è –≤ –æ–∫–Ω–µ –Ω–∏–∂–µ!

  –ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:

- —É–ª—É—á—à–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–ª–æ–∂–µ–Ω–∏—è –°–æ–ª–Ω—Ü–∞ –Ω–∞ –±–∞–∑–µ USNO (–¥–æ–±–∞–≤–ª–µ–Ω—ã
—ç—Ñ—Ñ–µ–∫—Ç—ã –Ω—É—Ç–∞—Ü–∏–∏, –ø—Ä–µ—Ü–µ—Å—Å–∏–∏ –∑–µ–º–Ω–æ–π–æ—Å–∏, –∞–±–µ—Ä–∞—Ü–∏–∏ —Å–≤–µ—Ç–∞, —É–ª—É—á—à–µ–Ω–Ω—ã–π
—Ä–∞—Å—á—ë—Ç —Ä–∞–∑–º–µ—Ä–æ–≤ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –¥–∏—Å–∫–∞)
- –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π —Ä–∞—Å—á—ë—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –°–æ–ª–Ω—Ü–∞
- –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–µ–π –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω–æ–π —Ä–µ—Ñ—Ä–∞–∫—Ü–∏–∏ (Stellarium –∏–ª–∏
Meeus 2 –∏–∑–¥–∞–Ω–∏—è)
- –∑–Ω–∞—á–µ–Ω–∏—è –¥–∞–≤–ª–µ–Ω–∏—è –∏ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: 1013.25 –≥–ü–∞/13¬∞–°
- –º–µ—Ç–µ–æ–¥–∞–Ω–Ω—ã–µ: https://api.open-meteo.com/v1/forecast/
- –≥–µ–æ–¥–∞–Ω–Ω—ã–µ: https://api.opentopodata.org/v1/
- —Ä–∞—Å—Å—á–µ—Ç –±–µ–ª—ã—Ö –Ω–æ—á–µ–π –º–µ—Ç–æ–¥–æ–º —Å–¥–≤–∏–≥–∞ —à–∏—Ä–æ—Ç—ã –∫ —é–≥—É –¥–æ –±–ª–∏–∂–∞–π—à–µ–≥–æ
–º–µ—Å—Ç–∞ –≥–¥–µ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –∞—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∞—è –Ω–æ—á—å
- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ—Ö–æ–¥–Ω–∞ –ª–µ—Ç–Ω–µ–µ/–∑–∏–º–Ω–µ–µ –≤—Ä–µ–º—è
- —Ä–∞—Å—Å—á–µ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ —Å –∫–æ—Ä—Ä–µ–∫—Ü–∏–µ–π –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω–æ–π —Ä–µ—Ñ—Ä–∞–∫—Ü–∏–∏ –∏
–æ–∫—Ä—É–≥–ª–æ—Å—Ç—å—é –∑–µ–º–Ω–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏

       ---------------

‚†Å‚¢Ä          –ê–≤—Ç–æ—Ä:
  ‚†Ñ   –ü–∞—á–∫—É–ª—è –ü—ë—Å—Ç—Ä–µ–Ω—å–∫–∏–π
  ‚†Ñ       –ë–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç–∏:
 ‚†Ç           –¢–æ—â–µ–≥,        ‚†à
   ‚†Ñ‚†à     –ß—É–ª–∏–∫,–¢–æ—Ç–æ—â   ‚°Ä ‚°Å ‚†Å

-->

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="ico_4.png">
  <link rel="apple-touch-icon" href="ico_4.png">
  <link rel="apple-touch-icon" sizes="512x512" href="ico_4.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>–ù–∞–º–∞–∑</title>
  <style>
    * { margin: 0;
      padding: 0;
      box-sizing: border-box;}
    body {
      font-family: Arial, sans-serif;
      width: 100vw;
      min-height: 100vh;
      padding: 8px;
      background: linear-gradient(135deg, #0c1445 0%, #1a237e 50%, #283593 100%);
      color: white;}
    .container {
      max-width: 100%;
      margin: 0 auto;}
    .header {
      text-align: center;
      margin-bottom: 8px;
      padding: 0px 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);}
    .header h1 {
      font-size: clamp(24px, 6vw, 32px);
      margin-top: 0px;
      margin-bottom: 0px;
      background: linear-gradient(45deg, #fff, #a8d8ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;}
    .date {
      font-size: clamp(16px, 4vw, 20px);
      opacity: 0.9;
      margin-bottom: 5px;}
    .time {
      font-size: clamp(18px, 5vw, 24px);
      font-weight: bold;
      opacity: 0.9;}
    .prayer-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 8px;
      font-family: monospace;
      font-size: clamp(16px, 4vw, 20px);
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);}
    .prayer-table th, .prayer-table td {
      padding: 16px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);}
    .prayer-table th {
      background-color: rgba(255, 255, 255, 0.2);
      font-weight: bold;
      text-align: center;
      font-size: clamp(14px, 3vw, 18px);}
    /* –¶–≤–µ—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω –Ω–∞–º–∞–∑–∞ */
    .fajr {background: linear-gradient(90deg, rgba(25, 25, 112, 0.9) 0%, rgba(65, 105, 225, 0.7) 100%);}
    .sunrise {background: linear-gradient(90deg, rgba(255, 140, 0, 0.9) 0%, rgba(255, 165, 0, 0.7) 100%);}
    .dhuhr {background: linear-gradient(90deg, rgba(255, 215, 0, 0.9) 0%, rgba(255, 255, 0, 0.7) 100%);}
    .asr {background: linear-gradient(90deg, rgba(255, 140, 0, 0.7) 0%, rgba(255, 69, 0, 0.5) 100%);}
    .maghrib {background: linear-gradient(90deg, rgba(178, 34, 34, 0.9) 0%, rgba(255, 69, 0, 0.7) 100%);}
    .isha {background: linear-gradient(90deg, rgba(25, 25, 112, 0.7) 0%, rgba(0, 0, 139, 0.9) 100%);}
    button {
      padding: 15px 25px;
      font-size: clamp(16px, 4vw, 18px);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s;}
    button:active {
      transform: scale(0.98);}
    .settings-page {
      display: none;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin-top: 0px;
      backdrop-filter: blur(10px);}
    .settings-group {
      margin-bottom: 20px;}
    .settings-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;}
    input[type="text"] {
      width: 100%;
      padding: 12px;
      margin: 5px 0;
      border: none;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.9);
      font-size: 16px;}
    .radio-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;}
    .radio-option {
      display: flex;
      align-items: center;
      margin-right: 15px;}
    .checkbox-option {
      display: flex;
      align-items: center;
      margin: 10px 0;}
    .save-btn {background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);}
    .reset-btn {background: linear-gradient(135deg, #f44336 0%, #da190b 100%);}
    .error {
      color: #ff6b6b;
      margin-top: 5px;
      font-size: 14px;}
    .white-night {
      color: #a8d8ff;
      font-style: italic;
      text-align: center;
      margin-top: 2px;
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(168, 216, 255, 0.2);
      border-radius: 8px;
      font-size: clamp(14px, 3vw, 16px);}
    .relief-result {
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-family: monospace;
      font-size: 12px;
      white-space: pre; /* pre-wrap */
      word-break: keep-all; /* break-all */
      max-height: 600px;
      overflow-y: auto;
      overflow-x: auto;
      border-radius: 5px;
      display: none;}
    @media (min-width: 768px) {
      .container {
        max-width: 480px;}
      .prayer-table {
        font-size: 18px;}
      button {
        width: auto;
        margin-top: 0;}
      .button-group {
        display: flex;
        gap: 10px;}
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ -->
    <div id="mainPage">
      <div class="header">
        <h1>–í—Ä–µ–º—è –Ω–∞–º–∞–∑–æ–≤</h1>
        <div class="date" id="currentDate"></div>
        <div class="time" id="currentTime"></div>
      </div>
      <div id="prayerTimesTable"></div>
      <div class="button-group">
        <button onclick="showSettings()">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
        <button onclick="calculateRelief()">–ü—Ä–æ—Å—á–∏—Ç–∞—Ç—å –≤–æ—Å—Ö–æ–¥/–∑–∞—Ö–æ–¥ —Å —É—á–µ—Ç–æ–º —Ä–µ–ª—å–µ—Ñ–∞</button>
      </div>
      <div id="reliefResult" class="relief-result"></div>
    </div>

    <!-- –°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ -->
    <div id="settingsPage" class="settings-page">
      <div class="settings-group">
        <label>–®–∏—Ä–æ—Ç–∞</label>
        <input type="text" id="latitude" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: 55.7558">
        <div id="latitudeError" class="error"></div>
      </div>

      <div class="settings-group">
        <label>–î–æ–ª–≥–æ—Ç–∞</label>
        <input type="text" id="longitude" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: 37.6173">
        <div id="longitudeError" class="error"></div>
      </div>

      <div class="settings-group">
        <label>–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å</label>
        <input type="text" id="timezone" value="0">
        <div id="timezoneError" class="error"></div>
      </div>

      <div class="settings-group">
        <label>–ü–µ—Ä–µ–≤–æ–¥–∏—Ç—Å—è –ª–∏ –≤—Ä–µ–º—è –Ω–∞ –ª–µ—Ç–Ω–µ–µ/–∑–∏–º–Ω–µ–µ</label>
        <div class="radio-group">
          <div class="radio-option">
            <input type="radio" id="daylightYes" name="daylight" value="1">
            <label for="daylightYes">–î–∞</label>
          </div>
          <div class="radio-option">
            <input type="radio" id="daylightNo" name="daylight" value="0" checked>
            <label for="daylightNo">–ù–µ—Ç</label>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <label>–£–≥–æ–ª 1 (—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å—É–º–µ—Ä–∫–∏)</label>
        <input type="text" id="angle1" value="18">
        <div id="angle1Error" class="error"></div>
      </div>

      <div class="settings-group">
        <label>–£–≥–æ–ª 2 (–≤–µ—á–µ—Ä–Ω–∏–µ —Å—É–º–µ—Ä–∫–∏)</label>
        <input type="text" id="angle2" value="17">
        <div id="angle2Error" class="error"></div>
      </div>

      <div class="settings-group">
        <div class="checkbox-option">
          <input type="checkbox" id="useWeather" name="useWeather">
          <label for="useWeather">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–µ—Ç–µ–æ–¥–∞–Ω–Ω—ã–µ (—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É –∏ –¥–∞–≤–ª–µ–Ω–∏–µ) –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–æ—Å—Ö–æ–¥–æ–≤ –∏ –∑–∞—Ö–æ–¥–æ–≤</label>
        </div>
      </div>

      <div class="button-group">
        <button class="save-btn" onclick="saveSettings()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        <button class="reset-btn" onclick="resetToDefault()">–°–±—Ä–æ—Å–∏—Ç—å</button>
      </div>
    </div>
  </div>

  <script>
    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
    const months_short = ['–Ø–ù–í', '–§–ï–í', '–ú–ê–†', '–ê–ü–†', '–ú–ê–ô', '–ò–Æ–ù', '–ò–Æ–õ', '–ê–í–ì', '–°–ï–ù', '–û–ö–¢', '–ù–û–Ø', '–î–ï–ö'];
    const months_long = ['–Ø–ù–í–ê–†–Ø', '–§–ï–í–†–ê–õ–Ø', '–ú–ê–†–¢–ê', '–ê–ü–†–ï–õ–Ø', '–ú–ê–Ø', '–ò–Æ–ù–Ø', '–ò–Æ–õ–Ø', '–ê–í–ì–£–°–¢–ê', '–°–ï–ù–¢–Ø–ë–†–Ø', '–û–ö–¢–Ø–ë–†–Ø', '–ù–û–Ø–ë–†–Ø', '–î–ï–ö–ê–ë–†–Ø'];
    const namazlar = ['–§–∞–¥–∂—Ä', '–í–æ—Å—Ö–æ–¥', '–ó—É—Ö—Ä', '–ê—Å—Ä', '–ú–∞–≥—Ä–∏–±', '–ò—à–∞'];
    const prayerClasses = ['fajr', 'sunrise', 'dhuhr', 'asr', 'maghrib', 'isha'];
    const no_night = "\"–ë–µ–ª—ã–µ –Ω–æ—á–∏\" - –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –Ω–æ—á—å –Ω–µ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç, —Ä–∞—Å—Å—á–µ—Ç –§–∞–¥–∂—Ä –∏ –ò—à–∞ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω –¥–ª—è –±–ª–∏–∂–∞–π—à–µ–≥–æ –º–µ—Å—Ç–∞ –≥–¥–µ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –Ω–æ—á—å";

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let m_dttm = [];
    let m_temp = [];
    let m_pres = [];
    let useWeatherData = false;

    // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    let debugInfo = "";

    // ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
    function is_leap(y) {
      return (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0));
    }

    function ut2dt(ut) {
      ut = Math.round(ut);
      let days = Math.floor(ut / 86400);
      let seconds_remaining = ut % 86400;
      let hours = Math.floor(seconds_remaining / 3600);
      seconds_remaining %= 3600;
      let minutes = Math.floor(seconds_remaining / 60);
      let seconds = seconds_remaining % 60;
      let year = 1970;

      while (days >= (is_leap(year) ? 366 : 365)) {
        days -= is_leap(year) ? 366 : 365;
        year++;
        if (year > 2100) break;
      }

      const month_days = [31, 28 + (is_leap(year) ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      let month = 1;
      for (let md of month_days) {
        if (days < md) break;
        days -= md;
        month++;
        if (month > 12) {
          month = 1;
          year++;
        }
      }
      return [year, month, days + 1, hours, minutes, seconds];
    }

    function dt2ut(year, month, day, hour = 0, minute = 0, second = 0) {
      if (year < 1970 || month < 1 || month > 12 || day < 1 || day > 31) {
        return 0;
      }

      let days = 0;
      for (let y = 1970; y < year; y++) {
        days += is_leap(y) ? 366 : 365;
      }

      const month_days = [31, 28 + (is_leap(year) ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      for (let m = 0; m < month - 1; m++) {
        days += month_days[m];
      }
      days += day - 1;
      return days * 86400 + hour * 3600 + minute * 60 + second;
    }

    function get_weekday(year, month, day) {
      if (month < 1 || month > 12 || day < 1 || day > 31) return 0;

      let m = month;
      let y = year;
      if (m < 3) {
        m += 12;
        y -= 1;
      }
      let k = y % 100;
      let j = Math.floor(y / 100);
      let h = (day + Math.floor(13 * (m + 1) / 5) + k + Math.floor(k / 4) + Math.floor(j / 4) + 5 * j) % 7;
      let r = (h + 6) % 7;
      return r;
    }

    function get_last_sunday(year, month, hour, minute, second, time_zone) {
      const month_days = [31, 28 + (is_leap(year) ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      if (month < 1 || month > 12) return 0;

      const last_day = month_days[month - 1];
      const last_weekday = get_weekday(year, month, last_day);
      const last_sunday_day = last_day - last_weekday;
      const ut = dt2ut(year, month, last_sunday_day, hour, minute, second);
      return ut - time_zone * 3600;
    }

    function is_dst(ut, time_zone, dst) {
      const dst_num = parseInt(dst, 10);
      if (dst_num === 0) {
        return 0;
      }

      try {
        const [year, month, day, hour, minute, second] = ut2dt(ut);
        const dst_start = get_last_sunday(year, 3, 2, 0, 0, time_zone);
        const dst_end = get_last_sunday(year, 10, 2, 0, 0, time_zone);
        const r = (dst_start <= ut && ut < dst_end) ? 1 : 0;
        return r;
      } catch (e) {
        console.error("Error in is_dst:", e);
        return 0;
      }
    }

    function normalize(value, base) {
      if (base === 0) return value;
      return value - base * Math.floor(value / base);
    }

    function f_to_hms(hh) {
      if (isNaN(hh) || !isFinite(hh)) {
        return [0, 0, 0];
      }

      let hours = Math.floor(hh);
      let minutes = (hh - hours) * 60;
      let min_int = Math.floor(minutes);
      let seconds = (minutes - min_int) * 60;
      let sec_int = Math.round(seconds);

      if (sec_int >= 60) {
        sec_int = 0;
        min_int += 1;
      }
      if (min_int >= 60) {
        min_int = 0;
        hours += 1;
      }
      if (hours >= 24) {
        hours -= 24;
      }
      return [hours, min_int, sec_int];
    }

    function f_to_hms_str(hours_decimal) {
      if (isNaN(hours_decimal) || !isFinite(hours_decimal)) {
        return "--:--:--";
      }

      hours_decimal = normalize(hours_decimal, 24);
      const [h, m, s] = f_to_hms(Math.abs(hours_decimal));
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function get_ut(timeString) {
      const year = parseInt(timeString.substring(0, 4));
      const month = parseInt(timeString.substring(5, 7));
      const day = parseInt(timeString.substring(8, 10));
      const hour = parseInt(timeString.substring(11, 13));
      return dt2ut(year, month, day, hour);
    }

    // ==================== –ü–û–ì–û–î–ù–´–ô API ====================
    async function get_weather_forecast(lat, lon) {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,pressure_msl&timezone=auto&forecast_days=2`;

      try {
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
      } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –ø–æ–≥–æ–¥—ã:", error);
        return null;
      }
    }

    // ==================== –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–ï –†–ê–°–ß–ï–¢–´ ====================
    function calc_jd(ut) {
      return 2440587.5 + (ut / 86400.0);
    }

    function usno_sun(ut) {
      try {
        const jd = calc_jd(ut);
        const D = jd - 2451545.0;
        let g = normalize(357.5291092 + 0.985600274 * D, 360);
        let q = normalize(280.4664567 + 0.985647366286 * D, 360);
        let L = normalize(q + 1.915 * Math.sin(g * Math.PI / 180) + 0.020 * Math.sin(2 * g * Math.PI / 180), 360);
        let e = normalize(23.439 - 0.00000036 * D, 360);
        e = normalize(e + 0.00256 * Math.cos((125.04 - 1934.136 * D / 36525) * Math.PI / 180), 360);
        let ra = Math.atan2(Math.cos(e * Math.PI / 180) * Math.sin(L * Math.PI / 180), Math.cos(L * Math.PI / 180)) * 180 / Math.PI;
        const dec = Math.asin(Math.sin(e * Math.PI / 180) * Math.sin(L * Math.PI / 180)) * 180 / Math.PI;
        if (ra < 0) ra += 360;
        const EqT = (q - ra) / 15.0;
        ra /= 15.0;
        const R = 1.00014 - 0.01671 * Math.cos(g * Math.PI / 180) - 0.00014 * Math.cos(2 * g * Math.PI / 180);
        const SD = 0.26656 / R;
        return [ra, dec, EqT, SD];
      } catch (e) {
        console.error("Error in usno_sun:", e);
        return [0, 0, 0, 0];
      }
    }

    function stellarium_refraction(geom_alt_deg, pressure = 1013.25, temperature = 15) {
      const MIN_GEO_ALTITUDE_DEG = -3.54;
      const TRANSITION_WIDTH_GEO_DEG = 1.46;

      const press_temp_corr = (pressure / 1010.0) * (283.0 / (273.0 + temperature)) / 60.0;
      let refraction_deg = 0.0;

      if (geom_alt_deg > MIN_GEO_ALTITUDE_DEG) {
        refraction_deg = press_temp_corr * (1.02 / Math.tan(
          (geom_alt_deg + 10.3 / (geom_alt_deg + 5.11)) * Math.PI / 180) + 0.0019279);

        const apparent_alt_deg = geom_alt_deg + refraction_deg;
        if (apparent_alt_deg > 90.0) {
          refraction_deg = 90.0 - geom_alt_deg;
        }
      } else if (geom_alt_deg > MIN_GEO_ALTITUDE_DEG - TRANSITION_WIDTH_GEO_DEG) {
        const r_m5 = press_temp_corr * (1.02 / Math.tan(
          (MIN_GEO_ALTITUDE_DEG + 10.3 / (MIN_GEO_ALTITUDE_DEG + 5.11)) * Math.PI / 180) + 0.0019279);
        const factor = (geom_alt_deg - (MIN_GEO_ALTITUDE_DEG - TRANSITION_WIDTH_GEO_DEG)) / TRANSITION_WIDTH_GEO_DEG;
        refraction_deg = r_m5 * factor;
      }

      return refraction_deg;
    }

    function calculate(latitude, longitude, ut, morning_twilight, evening_twilight,
             pressure = 1013.25, temperature = 15, sunrise_angle = 0, sunset_angle = 0) {
      try {
        morning_twilight = Math.abs(morning_twilight);
        evening_twilight = Math.abs(evening_twilight);
        const [ra, dec, EqT, SD] = usno_sun(ut);

        function Level(angle) {
          if (isNaN(angle)) return false;

          const numerator = Math.sin(-angle * Math.PI / 180) - Math.sin(dec * Math.PI / 180) * Math.sin(latitude * Math.PI / 180);
          const denominator = Math.cos(dec * Math.PI / 180) * Math.cos(latitude * Math.PI / 180);

          if (Math.abs(denominator) < 1e-10 || Math.abs(numerator) > Math.abs(denominator)) {
            return false;
          }

          const cos_val = numerator / denominator;
          if (Math.abs(cos_val) > 1) return false;

          return Math.acos(cos_val) * 180 / Math.PI / 15;
        }

        const t = [0, 0, 0, 0, 0, 0, 0];
        t[0] = 12 - longitude / 15.0 - EqT;

        const angle = SD + stellarium_refraction(0, pressure, temperature) - sunrise_angle;
        const lvl_val = Level(angle);
        t[1] = lvl_val !== false ? t[0] - lvl_val : false;

        const angle2 = SD + stellarium_refraction(0, pressure, temperature) - sunset_angle;
        const lvl_val2 = Level(angle2);
        t[2] = lvl_val2 !== false ? t[0] + lvl_val2 : false;

        const asr_angle = Math.atan(1.0 / (1.0 + Math.tan(Math.abs(latitude - dec) * Math.PI / 180))) * 180 / Math.PI;
        const asr_angle_corr = asr_angle - stellarium_refraction(asr_angle, pressure, temperature);
        const asr_level = Level(-asr_angle_corr);
        t[3] = asr_level !== false ? t[0] + asr_level : false;

        let ff = Level(morning_twilight);
        let ii = Level(evening_twilight);
        t[6] = (ff === false) || (ii === false);

        if (t[6]) {
          let adjusted_latitude = Math.acos(-Math.sin(-morning_twilight * Math.PI / 180)) * 180 / Math.PI - dec;
          adjusted_latitude -= 9e-8;
          latitude = adjusted_latitude;
          ff = Level(morning_twilight);
          ii = Level(evening_twilight);
        }
        t[4] = ff !== false ? t[0] - ff : false;
        t[5] = ii !== false ? t[0] + ii : false;
        return [t[4], t[1], t[0], t[3], t[2], t[5], t[6]];
      } catch (e) {
        console.error("Error in calculate:", e);
        return [false, false, false, false, false, false, false];
      }
    }

    function calc_plus(latitude, longitude, ut, morning_twilight, evening_twilight, sunrise_angle = 0, sunset_angle = 0) {
      try {
        let n = 0;
        if (m_dttm.length > 0) {
          if (ut - m_dttm[0] === 43200) {
            n = 0;
          } else if (ut - m_dttm[0] === 129600) {
            n = 24;
          } else {
            n = Math.floor((ut - m_dttm[0]) / 3600);
          }
        }

        const t = calculate(latitude, longitude, ut, morning_twilight, evening_twilight,
                 sunrise_angle, sunset_angle);
        const r = [0, 0, 0, 0, 0, 0, false];
        const c = [0, 0, 0, 0, 0, 0];

        for (let i = 0; i < 6; i++) {
          if (t[i] === false) {
            r[i] = false;
            continue;
          }
          r[i] = Math.round(t[i]);
        }

        let last_p = null;
        for (let i = 0; i < 6; i++) {
          if (t[i] === false) {
            r[i] = false;
            continue;
          }

          const pressure = m_pres.length > 0 ? m_pres[r[i] + n] : 1013.25;
          const temperature = m_temp.length > 0 ? m_temp[r[i] + n] : 15;

          last_p = calculate(latitude, longitude, ut - 43200 + t[i] * 3600,
                   morning_twilight, evening_twilight,
                   pressure, temperature, sunrise_angle, sunset_angle);
          c[i] = r[i] + n;
          r[i] = last_p[i];
        }
        r[6] = last_p ? last_p[6] : false;
        return [r, c];
      } catch (e) {
        console.error("Error in calc_plus:", e);
        return [[false, false, false, false, false, false, false], [0, 0, 0, 0, 0, 0]];
      }
    }

    // ==================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–°–ß–ï–¢–ê –†–ï–õ–¨–ï–§–ê ====================
    function sun_az_alt(latitude, longitude, ut) {
      const [ra, dec, EqT, SD] = usno_sun(ut);
      const [year, month, day, hour, minute, second] = ut2dt(ut);

      const t0 = 12 - longitude / 15.0 - EqT;
      const UT = hour + minute / 60 + second / 3600;
      const H_deg = (UT - t0) * 15.0;
      const H_rad = H_deg * Math.PI / 180;

      const fi = latitude * Math.PI / 180;
      const delta = dec * Math.PI / 180;
      let sin_h = Math.sin(fi) * Math.sin(delta) + Math.cos(fi) * Math.cos(delta) * Math.cos(H_rad);
      sin_h = Math.max(-1.0, Math.min(1.0, sin_h));
      const h = Math.asin(sin_h);

      let cos_A = (Math.sin(delta) - Math.sin(fi) * Math.sin(h)) / (Math.cos(fi) * Math.cos(h));
      cos_A = Math.max(-1.0, Math.min(1.0, cos_A));
      let A = Math.acos(cos_A);

      if (Math.sin(H_rad) > 0) {
        A = 2 * Math.PI - A;
      }

      let altitude_deg = h * 180 / Math.PI;
      altitude_deg += stellarium_refraction(altitude_deg);
      const azimuth_deg = A * 180 / Math.PI;

      return [azimuth_deg, altitude_deg];
    }

    function vincenty_direct(lat1, lon1, azi1, s) {
      const a = 6378137.0;
      const f = 1 / 298.257223563;
      const b = a * (1 - f);

      const phi1 = lat1 * Math.PI / 180;
      const lambda1 = lon1 * Math.PI / 180;
      const alpha1 = azi1 * Math.PI / 180;

      const tanU1 = (1 - f) * Math.tan(phi1);
      const cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1);
      const sinU1 = tanU1 * cosU1;
      const sin_alpha1 = Math.sin(alpha1);
      const cos_alpha1 = Math.cos(alpha1);

      const sigma1 = Math.atan2(tanU1, cos_alpha1);

      const sin_alpha = cosU1 * sin_alpha1;
      const cos2_alpha = 1 - sin_alpha * sin_alpha;

      let u2, A, B;
      if (Math.abs(cos2_alpha) < 1e-20) {
        u2 = 0.0;
        A = 1.0;
        B = 0.0;
      } else {
        u2 = cos2_alpha * (a * a - b * b) / (b * b);
        A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
        B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
      }

      let sigma = s / (b * A);

      for (let i = 0; i < 200; i++) {
        const cos2_sigma_m = Math.cos(2 * sigma1 + sigma);
        const sin_sigma = Math.sin(sigma);
        const cos_sigma = Math.cos(sigma);

        const delta_sigma = B * sin_sigma * (cos2_sigma_m + B / 4 * (
          cos_sigma * (-1 + 2 * cos2_sigma_m * cos2_sigma_m) -
          B / 6 * cos2_sigma_m * (-3 + 4 * sin_sigma * sin_sigma) *
          (-3 + 4 * cos2_sigma_m * cos2_sigma_m)
        ));

        const sigma_prev = sigma;
        sigma = s / (b * A) + delta_sigma;

        if (Math.abs(sigma - sigma_prev) < 1e-12) {
          break;
        }
      }

      const cos2_sigma_m = Math.cos(2 * sigma1 + sigma);
      const sin_sigma = Math.sin(sigma);
      const cos_sigma = Math.cos(sigma);

      const phi2_num = sinU1 * cos_sigma + cosU1 * sin_sigma * cos_alpha1;
      const phi2_den = (1 - f) * Math.sqrt(sin_alpha * sin_alpha +
        Math.pow(sinU1 * sin_sigma - cosU1 * cos_sigma * cos_alpha1, 2));
      const phi2 = Math.atan2(phi2_num, phi2_den);

      const lambda_num = sin_sigma * sin_alpha1;
      const lambda_den = cosU1 * cos_sigma - sinU1 * sin_sigma * cos_alpha1;
      const lambda_diff = Math.atan2(lambda_num, lambda_den);

      const C = f / 16 * cos2_alpha * (4 + f * (4 - 3 * cos2_alpha));
      const L = lambda_diff - (1 - C) * f * sin_alpha * (
        sigma + C * sin_sigma * (cos2_sigma_m + C * cos_sigma *
        (-1 + 2 * cos2_sigma_m * cos2_sigma_m)));

      const lambda2 = lambda1 + L;

      const alpha2 = Math.atan2(sin_alpha,
        -sinU1 * sin_sigma + cosU1 * cos_sigma * cos_alpha1);

      const lat2 = phi2 * 180 / Math.PI;
      const lon2 = lambda2 * 180 / Math.PI;
      const azi2 = (alpha2 * 180 / Math.PI + 360) % 360;

      return [lat2, lon2, azi2];
    }

    // ==================== –†–ï–®–ï–ù–ò–ï 1: OpenTopoData —Å CORS-–ø—Ä–æ–∫—Å–∏ ====================
    async function get_opentopodata_solution1(pos_list, dataset = "srtm30m", interpolation = "cubic") {
      if (pos_list.length > 100) {
        throw new Error("Open Topo Data API –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç 100 —Ç–æ—á–∫–∞–º–∏ –∑–∞ –∑–∞–ø—Ä–æ—Å");
      }

      const locations = pos_list.map(pos => `${pos[0]},${pos[1]}`).join("|");
      const baseUrl = `https://api.opentopodata.org/v1/${dataset}`;
      const params = {
        'locations': locations,
        'interpolation': interpolation
      };

      const queryString = new URLSearchParams(params).toString();

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º CORS-–ø—Ä–æ–∫—Å–∏
      const corsProxy = "https://corsproxy.io/?";
      const url = corsProxy + encodeURIComponent(`${baseUrl}?${queryString}`);

      try {
        debugInfo += `[–†–ï–®–ï–ù–ò–ï 1] –ó–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ CORS-–ø—Ä–æ–∫—Å–∏: ${url.substring(0, 100)}...\n`;

        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Python Elevation Client)',
            'Accept': 'application/json'
          },
          timeout: 15000 // 15 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP Error ${response.status}: ${errorText.substring(0, 200)}`);
        }

        const data = await response.json();

        if (data.status === 'OK') {
          debugInfo += `[–†–ï–®–ï–ù–ò–ï 1] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ ${data.results.length} –≤—ã—Å–æ—Ç\n`;
          return data.results.map(result =>
            result.elevation !== null ? Math.round(result.elevation) : 0
          );
        } else {
          throw new Error(`API error: ${data.error || 'Unknown error'}`);
        }
      } catch (error) {
        debugInfo += `[–†–ï–®–ï–ù–ò–ï 1] –û—à–∏–±–∫–∞: ${error.message}\n`;
        throw error; // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –¥–ª—è —Ä–µ—à–µ–Ω–∏—è 2
      }
    }

    // ==================== –†–ï–®–ï–ù–ò–ï 2: –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π API Open-Elevation ====================
    async function get_opentopodata_solution2(pos_list) {
      if (pos_list.length > 100) {
        throw new Error("Open-Elevation API –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç 100 —Ç–æ—á–∫–∞–º–∏ –∑–∞ –∑–∞–ø—Ä–æ—Å");
      }

      const locations = pos_list.map(pos => ({
        latitude: pos[0],
        longitude: pos[1]
      }));

      const url = "https://api.open-elevation.com/api/v1/lookup";

      try {
        debugInfo += `[–†–ï–®–ï–ù–ò–ï 2] –ó–∞–ø—Ä–æ—Å –∫ Open-Elevation API\n`;

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            locations: locations
          }),
          timeout: 15000
        });

        if (!response.ok) {
          throw new Error(`HTTP Error ${response.status}`);
        }

        const data = await response.json();

        if (data.results && data.results.length > 0) {
          debugInfo += `[–†–ï–®–ï–ù–ò–ï 2] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ ${data.results.length} –≤—ã—Å–æ—Ç\n`;
          return data.results.map(result =>
            result.elevation !== null ? Math.round(result.elevation) : 0
          );
        } else {
          throw new Error("No elevation data received");
        }
      } catch (error) {
        debugInfo += `[–†–ï–®–ï–ù–ò–ï 2] –û—à–∏–±–∫–∞: ${error.message}\n`;
        throw error; // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –¥–∞–ª—å—à–µ
      }
    }

    // ==================== –û–ë–™–ï–î–ò–ù–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ü–û–õ–£–ß–ï–ù–ò–Ø –í–´–°–û–¢ ====================
    async function get_opentopodata(pos_list, dataset = "srtm30m", interpolation = "cubic") {
      debugInfo += `–ó–∞–ø—Ä–æ—Å –≤—ã—Å–æ—Ç –¥–ª—è ${pos_list.length} —Ç–æ—á–µ–∫...\n`;

      try {
        // –ü—Ä–æ–±—É–µ–º –†–µ—à–µ–Ω–∏–µ 1 (OpenTopoData —Å CORS-–ø—Ä–æ–∫—Å–∏)
        debugInfo += `–ü—Ä–æ–±—É–µ–º –†–µ—à–µ–Ω–∏–µ 1 (OpenTopoData —Å CORS-–ø—Ä–æ–∫—Å–∏)...\n`;
        return await get_opentopodata_solution1(pos_list, dataset, interpolation);
      } catch (error1) {
        debugInfo += `–†–µ—à–µ–Ω–∏–µ 1 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ: ${error1.message}\n`;

        try {
          // –ü—Ä–æ–±—É–µ–º –†–µ—à–µ–Ω–∏–µ 2 (Open-Elevation)
          debugInfo += `–ü—Ä–æ–±—É–µ–º –†–µ—à–µ–Ω–∏–µ 2 (Open-Elevation API)...\n`;
          return await get_opentopodata_solution2(pos_list);
        } catch (error2) {
          debugInfo += `–†–µ—à–µ–Ω–∏–µ 2 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ: ${error2.message}\n`;
          throw new Error(`–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ä–µ–ª—å–µ—Ñ–∞. –û–±–µ API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.\n1) ${error1.message}\n2) ${error2.message}`);
        }
      }
    }

    function make_pos_list(lat, lon, az, dist_m = 16000, step_m = 50) {
      const l = Math.floor(dist_m / step_m) + 1;
      const result = new Array(l);
      result[0] = [lat, lon];

      for (let i = 1; i < l; i++) {
        const t = vincenty_direct(lat, lon, az, step_m * i);
        result[i] = [t[0], t[1]];
      }

      return result;
    }

    function correction(h_list, step = 50, h_observer = 1.75, idx = 0) {
      const R = 6371000.0;
      const pressure = m_pres.length > idx && m_pres[idx] !== undefined ? m_pres[idx] : 1013.25;
      const temperature = m_temp.length > idx && m_temp[idx] !== undefined ? m_temp[idx] : 15;
      const k = 0.142 * (pressure/1013.25) * (288.15/(temperature + 273.15));
      //const k = (1/6.0) * (m_pres[idx]/1013.25) * (288.15/(m_temp[idx] + 273.15));
      const R_eff = R / (1 - k);
      const observer_total = h_list[0] + h_observer;
      const h_corrected = new Array(h_list.length);

      h_corrected[0] = h_list[0] - observer_total;

      for (let i = 1; i < h_list.length; i++) {
        const dist = i * step;
        h_corrected[i] = h_list[i] - observer_total - (dist * dist) / (2 * R_eff);
      }

      return h_corrected;
    }

    function horizon(corrected, h_list, step = 50) {
      let tan_h_max = -Infinity;
      let i_max = 0;

      for (let i = 1; i < corrected.length; i++) {
        const dist = i * step;
        const tan_h = corrected[i] / dist;
        if (tan_h > tan_h_max) {
          tan_h_max = tan_h;
          i_max = i;
        }
      }

      const alpha = Math.atan(tan_h_max) * 180 / Math.PI;
      return [h_list[i_max], i_max * step, alpha];
    }

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function graph(corrected,
           h_observer,
           step = 50,
           h_div = 10,
           w_div = -1,
           hrzn_i = 0,
           scr_w = 32) {

      function rnd(x, div) {
        return Math.round(x / div) * div;
      }

      const observer_mark = rnd(h_observer, h_div);
      const max_h = Math.max(Math.max(...corrected) + h_observer, observer_mark);
      const min_h = Math.min(Math.min(...corrected) + h_observer, observer_mark);
      const delta = max_h - min_h;
      const insert = Math.max(
        Math.round(max_h).toString().length,
        Math.round(min_h).toString().length
      );

      let result = "";

      if (w_div === -1) {
        scr_w -= insert;
        const total_w = corrected.length;
        w_div = Math.round(total_w / scr_w);
      }

      let actualStep = step;
      let processedCorrected = [...corrected];
      let processedHrznI = hrzn_i;
      if (w_div > 1) {
        actualStep *= w_div;
        processedHrznI = Math.round(hrzn_i / w_div);
        processedCorrected = [];

        for (let i = 0; i < corrected.length; i += w_div) {
          // –í Python –æ—Ä–∏–≥–∏–Ω–∞–ª–µ –ó–ê–ö–û–ú–ú–ï–ù–¢–ò–†–û–í–ê–ù–û —É—Å–ª–æ–≤–∏–µ if i == 0!
          // –ü–æ—ç—Ç–æ–º—É –í–°–ï–ì–î–ê –±–µ—Ä–µ–º max –∏–∑ —Å—Ä–µ–∑–∞
          const slice = corrected.slice(i, i + w_div);
          processedCorrected.push(Math.max(...slice));
        }
      }
      if (processedHrznI > 2) {
       processedHrznI -= 1
      }
      const x = Math.round(delta / h_div);
      for (let i = 0; i < processedCorrected.length; i++) {
        let h = processedCorrected[i];
        h += h_observer;
        const l = Math.round((h - min_h) / h_div);
        let c;
        if (i === processedHrznI) {
          c = "A";
        } else {
          c = "o";
        }

        result += c.repeat(l + 1) +
             ".".repeat(x - l) +
             "\n";
      }
      const d = Math.round(delta / h_div);
      const vals = [];

      for (let i = d; i >= 0; i--) {
        const value = rnd(i * h_div + min_h, h_div);
        if (value === observer_mark) {
          vals.push(value.toString().padStart(insert, ".") + "@");
        } else {
          vals.push(value.toString().padStart(insert, ".") + "|");
        }
      }

      const rows = result.slice(0, -1).split("\n");
      result = "";

      // –ø–æ–≤–æ—Ä–æ—Ç –Ω–∞ 90¬∞ –ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–∏
      const maxRowLength = Math.max(...rows.map(row => row.length));
      let rotated = [];

      for (let i = 0; i < maxRowLength; i++) {
        const col = rows.map(row => row[i] || " ");
        rotated.push(col);
      }
      rotated = rotated.reverse();

      for (let i = 0; i < vals.length; i++) {
        result += vals[i] +
             rotated[i].join("") +
             "\n";
      }

      result += ".".repeat(insert) +
           "+" +
           "~".repeat(processedCorrected.length) +
           "\n";

      const nums = [];
      for (let i = 0; i <= processedCorrected.length; i++) {
        if (i % 2 === 0) {
          nums.push((i * actualStep).toString());
        } else {
          nums.push("0");
        }
      }

      const maxLen = Math.max(...nums.map(n => n.length));
      const paddedNums = nums.map(n => n.padStart(maxLen, "0"));
      const scale = [];

      for (let pos = 0; pos < maxLen; pos++) {
        let line = ".".repeat(insert);
        for (let n of paddedNums) {
          // –µ—Å–ª–∏ —ç—Ç–æ –≤–µ–¥—É—â–∏–π –Ω–æ–ª—å ‚Äî –∑–∞–º–µ–Ω—è–µ–º —Ç–æ—á–∫–æ–π
          if (n[pos] === "0" && pos < maxLen - n.replace(/^0+/, "").length) {
            line += ".";
          } else {
            line += n[pos];
          }
        }
        scale.push(line);
      }

      result += scale.join("\n");
      return result;
    }


    // ==================== –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –†–ê–°–ß–ï–¢–ê –†–ï–õ–¨–ï–§–ê –° –û–¢–õ–ê–î–ö–û–ô ====================
    async function calc_with_relief(dist = 15950, step = 50) {
      debugInfo = "=== –ù–ê–ß–ê–õ–û –†–ê–°–ß–ï–¢–ê –†–ï–õ–¨–ï–§–ê ===\n\n";

      try {
        const latitude = parseFloat(document.getElementById('latitude').value);
        const longitude = parseFloat(document.getElementById('longitude').value);
        const time_zone = parseInt(document.getElementById('timezone').value);
        const dst_element = document.querySelector('input[name="daylight"]:checked');
        const dst = dst_element ? dst_element.value : "0";
        const morning_twilight = parseFloat(document.getElementById('angle1').value);
        const evening_twilight = parseFloat(document.getElementById('angle2').value);

        debugInfo += `–í—Ö–æ–¥–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:\n`;
        debugInfo += `–®–∏—Ä–æ—Ç–∞: ${latitude}\n`;
        debugInfo += `–î–æ–ª–≥–æ—Ç–∞: ${longitude}\n`;
        debugInfo += `–£–≥–æ–ª 1: ${morning_twilight}\n`;
        debugInfo += `–£–≥–æ–ª 2: ${evening_twilight}\n`;
        debugInfo += `–î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${dist} –º\n`;
        debugInfo += `–®–∞–≥: ${step} –º\n\n`;

        if (isNaN(latitude) || isNaN(longitude)) {
          debugInfo += "–û—à–∏–±–∫–∞: –ù–µ –∑–∞–¥–∞–Ω—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã\n";
          return debugInfo;
        }

        if (latitude >= 60) {
          debugInfo += "–û—à–∏–±–∫–∞: –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å —Ä–µ–ª—å–µ—Ñ —Å–µ–≤–µ—Ä–Ω–µ–µ 60¬∞ —Å.—à.\n";
          return debugInfo;
        }

        const ut = Math.floor(Date.now() / 1000);
        const base_ut = ut - (ut % 86400) + 12 * 3600;

        debugInfo += `–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è (UTC): ${new Date(ut * 1000).toISOString()}\n`;
        debugInfo += `–ë–∞–∑–æ–≤–æ–µ –≤—Ä–µ–º—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤ (UTC): ${new Date(base_ut * 1000).toISOString()}\n\n`;

        // –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º–µ–Ω–∞ –Ω–∞–º–∞–∑–æ–≤ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∞–∑–∏–º—É—Ç–æ–≤
        const t_result = calc_plus(latitude, longitude, base_ut, morning_twilight, evening_twilight);
        const t = t_result[0];
        const c = t_result[1];

        debugInfo += `–†–µ–∑—É–ª—å—Ç–∞—Ç—ã calc_plus:\n`;
        for (let i = 0; i < t.length; i++) {
          debugInfo += `t[${i}] = ${t[i]}\n`;
        }
        debugInfo += `–ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã/–¥–∞–≤–ª–µ–Ω–∏—è: ${c.join(', ')}\n\n`;

        if (t[1] === false || t[4] === false) {
          debugInfo += "–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –≤—Ä–µ–º—è –≤–æ—Å—Ö–æ–¥–∞/—Ñ–∞–¥–∂—Ä\n";
          return debugInfo;
        }

        debugInfo += `–í—Ä–µ–º—è –≤–æ—Å—Ö–æ–¥–∞ (—á–∞—Å—ã –æ—Ç –ø–æ–ª—É–Ω–æ—á–∏ UTC): ${t[1]}\n`;
        debugInfo += `–í—Ä–µ–º—è –∑–∞—Ö–æ–¥–∞ (—á–∞—Å—ã –æ—Ç –ø–æ–ª—É–Ω–æ—á–∏ UTC): ${t[4]}\n\n`;

        // –ü–æ–ª—É—á–∞–µ–º –∞–∑–∏–º—É—Ç—ã —Å–æ–ª–Ω—Ü–∞ –≤ –º–æ–º–µ–Ω—Ç—ã –≤–æ—Å—Ö–æ–¥–∞ –∏ —Ñ–∞–¥–∂—Ä–∞
        const sunrise_ut = base_ut - 12 * 3600 + t[1] * 3600;
        const sunset_ut = base_ut - 12 * 3600 + t[4] * 3600;

        debugInfo += `–í—Ä–µ–º—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∞–∑–∏–º—É—Ç–∞ –≤–æ—Å—Ö–æ–¥–∞ (UTC): ${new Date(sunrise_ut * 1000).toISOString()}\n`;
        debugInfo += `–í—Ä–µ–º—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∞–∑–∏–º—É—Ç–∞ –∑–∞—Ö–æ–¥–∞ (UTC): ${new Date(sunset_ut * 1000).toISOString()}\n\n`;

        const az1_result = sun_az_alt(latitude, longitude, sunrise_ut);
        const az2_result = sun_az_alt(latitude, longitude, sunset_ut);

        const az1 = az1_result[0];
        const az2 = az2_result[0];

        debugInfo += `–ê–∑–∏–º—É—Ç –≤–æ—Å—Ö–æ–¥–∞: ${az1.toFixed(2)}¬∞\n`;
        debugInfo += `–í—ã—Å–æ—Ç–∞ –≤–æ—Å—Ö–æ–¥–∞: ${az1_result[1].toFixed(2)}¬∞\n`;
        debugInfo += `–ê–∑–∏–º—É—Ç –∑–∞—Ö–æ–¥–∞: ${az2.toFixed(2)}¬∞\n`;
        debugInfo += `–í—ã—Å–æ—Ç–∞ –∑–∞—Ö–æ–¥–∞: ${az2_result[1].toFixed(2)}¬∞\n\n`;

        debugInfo += `–†–∞–∑–Ω–∏—Ü–∞ –∞–∑–∏–º—É—Ç–æ–≤: ${Math.abs(az1 - az2).toFixed(2)}¬∞\n`;

        if (Math.abs(az1 - az2) < 1) {
          debugInfo += "–í–ù–ò–ú–ê–ù–ò–ï: –ê–∑–∏–º—É—Ç—ã –ø–æ—á—Ç–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ! –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—à–∏–±–∫–æ–π.\n\n";
        } else {
          debugInfo += "–ê–∑–∏–º—É—Ç—ã —Ä–∞–∑–ª–∏—á–∞—é—Ç—Å—è - —ç—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ.\n\n";
        }

        // –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–∫–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –¥–ª—è –≤–æ—Å—Ö–æ–¥–∞ –∏ –∑–∞–∫–∞—Ç–∞
        debugInfo += `–°–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–æ–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç...\n`;
        const p_list1 = make_pos_list(latitude, longitude, az1, dist, step);
        const p_list2 = make_pos_list(latitude, longitude, az2, dist, step);

        debugInfo += `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–ª—è –≤–æ—Å—Ö–æ–¥–∞: ${p_list1.length}\n`;
        debugInfo += `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–ª—è –∑–∞–∫–∞—Ç–∞: ${p_list2.length}\n\n`;

        debugInfo += `–ü–µ—Ä–≤—ã–µ 3 —Ç–æ—á–∫–∏ –¥–ª—è –≤–æ—Å—Ö–æ–¥–∞:\n`;
        for (let i = 0; i < Math.min(3, p_list1.length); i++) {
          debugInfo += ` [${i}]: ${p_list1[i][0].toFixed(4)}¬∞, ${p_list1[i][1].toFixed(4)}¬∞\n`;
        }
        debugInfo += `\n–ü–µ—Ä–≤—ã–µ 3 —Ç–æ—á–∫–∏ –¥–ª—è –∑–∞–∫–∞—Ç–∞:\n`;
        for (let i = 0; i < Math.min(3, p_list2.length); i++) {
          debugInfo += ` [${i}]: ${p_list2[i][0].toFixed(4)}¬∞, ${p_list2[i][1].toFixed(4)}¬∞\n`;
        }
        debugInfo += `\n`;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–∞–∑–Ω—ã–µ –ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        const same_coords = p_list1[1][0] === p_list2[1][0] && p_list1[1][1] === p_list2[1][1];
        debugInfo += `–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Ç–æ—Ä–æ–π —Ç–æ—á–∫–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ? ${same_coords ? '–î–ê - –û–®–ò–ë–ö–ê!' : '–ù–ï–¢ - –ø—Ä–∞–≤–∏–ª—å–Ω–æ'}\n\n`;

        // –ü–æ–ª—É—á–∞–µ–º –≤—ã—Å–æ—Ç—ã –¥–ª—è —Ç–æ—á–µ–∫ –≤–æ—Å—Ö–æ–¥–∞
        debugInfo += `–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã—Å–æ—Ç –¥–ª—è —Ç–æ—á–µ–∫ –≤–æ—Å—Ö–æ–¥–∞...\n`;
        let h_list1 = [];
        for (let i = 0; i < p_list1.length; i += 100) {
          const chunk = p_list1.slice(i, i + 100);
          await sleep(667);
          try {
            debugInfo += ` –ó–∞–ø—Ä–æ—Å —Ç–æ—á–µ–∫ ${i}-${Math.min(i+99, p_list1.length-1)}...\n`;
            const elevations = await get_opentopodata(chunk, "srtm30m", "cubic");
            h_list1.push(...elevations);
            debugInfo += ` –ü–æ–ª—É—á–µ–Ω–æ ${elevations.length} –≤—ã—Å–æ—Ç\n`;
          } catch (error) {
            debugInfo += ` –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: ${error.message}\n`;
            throw error;
          }
        }
        debugInfo += `\n–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã—Å–æ—Ç –¥–ª—è —Ç–æ—á–µ–∫ –∑–∞–∫–∞—Ç–∞...\n`;
        let h_list2 = [];
        for (let i = 0; i < p_list2.length; i += 100) {
          const chunk = p_list2.slice(i, i + 100);
          await sleep(667);
          try {
            debugInfo += ` –ó–∞–ø—Ä–æ—Å —Ç–æ—á–µ–∫ ${i}-${Math.min(i+99, p_list2.length-1)}...\n`;
            const elevations = await get_opentopodata(chunk, "srtm30m", "cubic");
            h_list2.push(...elevations);
            debugInfo += ` –ü–æ–ª—É—á–µ–Ω–æ ${elevations.length} –≤—ã—Å–æ—Ç\n`;
          } catch (error) {
            debugInfo += ` –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: ${error.message}\n`;
            throw error;
          }
        }

        debugInfo += `\n–ü–µ—Ä–≤—ã–µ 50 –≤—ã—Å–æ—Ç –¥–ª—è –≤–æ—Å—Ö–æ–¥–∞: ${h_list1.slice(0, 50).join(', ')}\n`;
        debugInfo += `–ü–µ—Ä–≤—ã–µ 50 –≤—ã—Å–æ—Ç –¥–ª—è –∑–∞–∫–∞—Ç–∞: ${h_list2.slice(0, 50).join(', ')}\n\n`;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–∞–∑–Ω—ã–µ –ª–∏ –≤—ã—Å–æ—Ç—ã
        const same_heights = JSON.stringify(h_list1.slice(0, 5)) === JSON.stringify(h_list2.slice(0, 5));
        debugInfo += `–í—ã—Å–æ—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ? ${same_heights ? '–î–ê - –≤–æ–∑–º–æ–∂–Ω–æ –æ—à–∏–±–∫–∞' : '–ù–ï–¢ - –ø—Ä–∞–≤–∏–ª—å–Ω–æ'}\n\n`;

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏
        debugInfo += `–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–∫—Ü–∏–π...\n`;
        const hc1 = correction(h_list1, step, 1.75, c[1]);
        const hc2 = correction(h_list2, step, 1.75, c[4]);

        debugInfo += `–ò–Ω–¥–µ–∫—Å –¥–ª—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã/–¥–∞–≤–ª–µ–Ω–∏—è –≤–æ—Å—Ö–æ–¥–∞: ${c[1]}\n`;
        debugInfo += `–ò–Ω–¥–µ–∫—Å –¥–ª—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã/–¥–∞–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞—Ç–∞: ${c[4]}\n`;
        debugInfo += `–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –≤–æ—Å—Ö–æ–¥–∞: ${m_temp.length > c[1] ? m_temp[c[1]] : '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n`;
        debugInfo += `–î–∞–≤–ª–µ–Ω–∏–µ –≤–æ—Å—Ö–æ–¥–∞: ${m_pres.length > c[1] ? m_pres[c[1]] : '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n`;
        debugInfo += `–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –∑–∞–∫–∞—Ç–∞: ${m_temp.length > c[4] ? m_temp[c[4]] : '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n`;
        debugInfo += `–î–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞—Ç–∞: ${m_pres.length > c[4] ? m_pres[c[4]] : '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n\n`;

        // –ù–∞—Ö–æ–¥–∏–º –≥–æ—Ä–∏–∑–æ–Ω—Ç
        debugInfo += `–ü–æ–∏—Å–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞...\n`;
        const [h1, d1, a1] = horizon(hc1, h_list1, step);
        const [h2, d2, a2] = horizon(hc2, h_list2, step);

        debugInfo += `–í–æ—Å—Ö–æ–¥: –≤—ã—Å–æ—Ç–∞=${h1.toFixed(0)}–º, –¥–∏—Å—Ç–∞–Ω—Ü–∏—è=${d1}–º, —É–≥–æ–ª=${a1.toFixed(4)}¬∞\n`;
        debugInfo += `–ó–∞–∫–∞—Ç: –≤—ã—Å–æ—Ç–∞=${h2.toFixed(0)}–º, –¥–∏—Å—Ç–∞–Ω—Ü–∏—è=${d2}–º, —É–≥–æ–ª=${a2.toFixed(4)}¬∞\n\n`;

        // –ù–∞—Ö–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–µ–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞
        debugInfo += `–†–∞—Å—á–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ç–æ—á–µ–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞...\n`;
        const t1 = vincenty_direct(latitude, longitude, az1, d1);
        const t2 = vincenty_direct(latitude, longitude, az2, d2);

        debugInfo += `–¢–æ—á–∫–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ –≤–æ—Å—Ö–æ–¥–∞: ${t1[0].toFixed(4)}¬∞, ${t1[1].toFixed(4)}¬∞\n`;
        debugInfo += `–¢–æ—á–∫–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ –∑–∞–∫–∞—Ç–∞: ${t2[0].toFixed(4)}¬∞, ${t2[1].toFixed(4)}¬∞\n\n`;

        // hrzn_i1 –∏ hrzn_i2 - –∏–Ω–¥–µ–∫—Å—ã —Ç–æ—á–µ–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞:
        const hrzn_i1 = Math.floor(d1 / step); // –¥–ª—è –≤–æ—Å—Ö–æ–¥–∞
        const hrzn_i2 = Math.floor(d2 / step); // –¥–ª—è –∑–∞–∫–∞—Ç–∞

        // –û—Ç–ª–∞–¥–∫–∞ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –≤—ã—Å–æ—Ç
        debugInfo += `\n–û—Ç–ª–∞–¥–∫–∞ –≤—ã—Å–æ—Ç –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞:\n`;
        debugInfo += `–í—ã—Å–æ—Ç–∞ –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è: ${h_list1[0]} –º\n`;
        debugInfo += `–ü–µ—Ä–≤—ã–µ 50 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤—ã—Å–æ—Ç: ${hc1.slice(0, 50).map(h => h.toFixed(1)).join(', ')}\n`;
        debugInfo += `–ü–µ—Ä–≤—ã–µ 50 –ø–æ–ª–Ω—ã—Ö –≤—ã—Å–æ—Ç: ${hc1.slice(0, 50).map(h => (h + h_list1[0]).toFixed(1)).join(', ')}\n`;
        debugInfo += `–ò–Ω–¥–µ–∫—Å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞: ${hrzn_i1}, –∑–Ω–∞—á–µ–Ω–∏–µ: ${hc1[hrzn_i1] + h_list1[0]} –º\n`;

        // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è –∑–∞–∫–∞—Ç–∞
        debugInfo += `\n–î–ª—è –∑–∞–∫–∞—Ç–∞:\n`;
        debugInfo += `–í—ã—Å–æ—Ç–∞ –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è: ${h_list2[0]} –º\n`;
        debugInfo += `–ü–µ—Ä–≤—ã–µ 50 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤—ã—Å–æ—Ç: ${hc2.slice(0, 50).map(h => h.toFixed(1)).join(', ')}\n`;
        debugInfo += `–ü–µ—Ä–≤—ã–µ 50 –ø–æ–ª–Ω—ã—Ö –≤—ã—Å–æ—Ç: ${hc2.slice(0, 50).map(h => (h + h_list2[0]).toFixed(1)).join(', ')}\n`;
        debugInfo += `–ò–Ω–¥–µ–∫—Å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞: ${hrzn_i2}, –∑–Ω–∞—á–µ–Ω–∏–µ: ${hc2[hrzn_i2] + h_list2[0]} –º\n`;


        const sunriseGraph = graph(hc1, h_list1[0], step, 10, 5, hrzn_i1, 36);
        const sunsetGraph = graph(hc2, h_list2[0], step, 10, 5, hrzn_i2, 36);


        const ptm = await get_today(latitude, longitude, time_zone, dst, morning_twilight, evening_twilight, a1, a2);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –æ—à–∏–±–∫–∏
        if (ptm.error) {
          debugInfo += `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –≤—Ä–µ–º–µ–Ω–∏: ${ptm.error}\n`;
          // –ú–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–ª–∏ –≤—ã–±—Ä–æ—Å–∏—Ç—å –æ—à–∏–±–∫—É
        }

        // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –≤—ã–≤–æ–¥–∞
        let ptm_str = "";
        if (ptm.times && ptm.times.length > 0) {
          ptm_str += `=== –í–†–ï–ú–Ø –í–û–°–•–û–î–ê –ò –ó–ê–•–û–î–ê –° –£–ß–ï–¢–û–ú –†–ï–õ–¨–ï–§–ê ===\n`;
          //ptm_str += `(–∫–æ—Ä—Ä–µ–∫—Ü–∏—è —É–≥–ª–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞:
        //–≤–æ—Å—Ö–æ–¥ ${a1.toFixed(2)}¬∞
        //–∑–∞—Ö–æ–¥ ${a2.toFixed(2)}¬∞)\n\n`;

        // –í–æ—Å—Ö–æ–¥ - –∏–Ω–¥–µ–∫—Å 1, –ú–∞–≥—Ä–∏–± - –∏–Ω–¥–µ–∫—Å 4 –≤ –º–∞—Å—Å–∏–≤–µ namazlar
        const sunriseIndex = 1; // "–í–æ—Å—Ö–æ–¥"
        const maghribIndex = 4; // "–ú–∞–≥—Ä–∏–±"

        if (ptm.times[sunriseIndex]) {
          ptm_str += `–í–∏–¥–∏–º—ã–π –≤–æ—Å—Ö–æ–¥: ${ptm.times[sunriseIndex].today} (–∑–∞–≤—Ç—Ä–∞: ${ptm.times[sunriseIndex].tomorrow})\n`;
        }
        if (ptm.times[maghribIndex]) {
          ptm_str += `–í–∏–¥–∏–º—ã–π –∑–∞—Ö–æ–¥ : ${ptm.times[maghribIndex].today} (–∑–∞–≤—Ç—Ä–∞: ${ptm.times[maghribIndex].tomorrow})\n`;
        }

        } else {
          ptm_str = "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –≤—Ä–µ–º—è –Ω–∞–º–∞–∑–æ–≤ —Å —É—á–µ—Ç–æ–º —Ä–µ–ª—å–µ—Ñ–∞";
        }


        // –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        //const info = `=== –ò–¢–û–ì–û–í–´–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´ –†–ê–°–ß–ï–¢–ê –†–ï–õ–¨–ï–§–ê ===
        //const info = `${ptm_str}
        const info = `–û–ñ–ò–î–ê–ï–ú–û–ï –í–†–ï–ú–Ø –í–û–°–•–û–î–ê –ò –ó–ê–•–û–î–ê –° –£–ß–ï–¢–û–ú –†–ï–õ–¨–ï–§–ê

–í–û–°–•–û–î : ${ptm.times[1].today}
–ê–∑–∏–º—É—Ç : ${az1.toFixed(2)}¬∞
–õ–æ–∫–∞—Ü–∏—è: ${t1[0].toFixed(4)}¬∞, ${t1[1].toFixed(4)}¬∞
–í—ã—Å–æ—Ç–∞ : ${h1.toFixed(0)}–º
–î–∏—Å—Ç–∞–Ω—Ü: ${d1}–º
–£–≥–æ–ª   : ${a1.toFixed(4)}¬∞
–¢–µ–º–ø.  : ${m_temp[c[1]]}¬∞C
–î–∞–≤–ª.  : ${m_pres[c[1]]}–≥–ü–∞
${sunriseGraph}

–ó–ê–•–û–î  : ${ptm.times[4].today}
–ê–∑–∏–º—É—Ç : ${az2.toFixed(2)}¬∞
–õ–æ–∫–∞—Ü–∏—è: ${t2[0].toFixed(4)}¬∞, ${t2[1].toFixed(4)}¬∞
–í—ã—Å–æ—Ç–∞ : ${h2.toFixed(0)}–º
–î–∏—Å—Ç–∞–Ω—Ü: ${d2}–º
–£–≥–æ–ª   : ${a2.toFixed(4)}¬∞
–¢–µ–º–ø.  : ${m_temp[c[4]]}¬∞C
–î–∞–≤–ª.  : ${m_pres[c[4]]}–≥–ü–∞
${sunsetGraph}

________________________
@ - —Ç–æ—á–∫–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è
–ê - —Ç–æ—á–∫–∞ –≤–æ—Å—Ö–æ–¥–∞/–∑–∞—Ö–æ–¥–∞
`;

//=== –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û–¢–õ–ê–î–ö–ò ===
//${debugInfo}`;

        return info;

      } catch (error) {
        debugInfo += `\n‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: ${error.message}\n`;
        return `‚ùå –ù–ï–í–û–ó–ú–û–ñ–ù–û –†–ê–°–°–ß–ò–¢–ê–¢–¨ –†–ï–õ–¨–ï–§\n\n${debugInfo}\n\n–ü—Ä–∏—á–∏–Ω–∞: ${error.message}\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ\n2. –£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã\n3. –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ (API –º–æ–≥—É—Ç –±—ã—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã)`;
      }
    }

    // ==================== –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –†–ê–°–ß–ï–¢–ê –ù–ê–ú–ê–ó–û–í ====================
    async function get_today(latitude, longitude, time_zone, dst, morning_twilight, evening_twilight, sunrise_angle=0, sunset_angle=0) {
      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      const tz = parseInt(time_zone, 10);
      const dst_num = parseInt(dst, 10);
      const morn_tw = parseFloat(morning_twilight);
      const even_tw = parseFloat(evening_twilight);

      if (isNaN(lat) || isNaN(lon) || isNaN(tz) || isNaN(dst_num) ||
        isNaN(morn_tw) || isNaN(even_tw)) {
        return {error: "–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∞—Å—á–µ—Ç–∞"};
      }

      try {
        const ut = Math.floor(Date.now() / 1000);
        const base_ut = ut - (ut % 86400) + 12 * 3600;

        if (useWeatherData) {
          const weatherData = await get_weather_forecast(lat, lon);
          if (weatherData && weatherData.hourly) {
            m_dttm = [];
            m_temp = [];
            m_pres = [];

            for (let i = 0; i < 48; i++) {
              if (weatherData.hourly.time[i]) {
                m_dttm.push(get_ut(weatherData.hourly.time[i]));
              }
              if (weatherData.hourly.temperature_2m && i < weatherData.hourly.temperature_2m.length) {
                m_temp.push(weatherData.hourly.temperature_2m[i]);
              }
              if (weatherData.hourly.pressure_msl && i < weatherData.hourly.pressure_msl.length) {
                m_pres.push(weatherData.hourly.pressure_msl[i]);
              }
            }
          }
        } else {
          m_dttm = [];
          m_temp = [];
          m_pres = [];

          for (let i = 0; i < 48; i++) {
            m_dttm.push(base_ut + i * 3600);
            m_temp.push(15);
            m_pres.push(1013.25);
          }
        }

        const t_result = calc_plus(lat, lon, base_ut, morn_tw, even_tw, sunrise_angle, sunset_angle);
        const p_result = calc_plus(lat, lon, base_ut + 86400, morn_tw, even_tw, sunrise_angle, sunset_angle);

        const t = t_result[0];
        const p = p_result[0];

        const today_offset = tz + is_dst(base_ut, tz, dst_num);
        const tomorrow_offset = tz + is_dst(base_ut + 86400, tz, dst_num);

        const [_, month, day, __, ___, ____] = ut2dt(base_ut + today_offset * 3600);

        const result = {
          date: `${day.toString().padStart(2, '0')} ${months_short[month - 1]}`,
          times: [],
          hasWhiteNights: false
        };

        for (let i = 0; i < 6; i++) {
          const tt_offset = tz + is_dst(base_ut + t[i] * 3600.0, tz, dst_num);
          const tp_offset = tz + is_dst(base_ut + p[i] * 3600.0 + 86400, tz, dst_num);

          let todayTime = t[i] !== false ? f_to_hms_str(t[i] + tt_offset) : "--:--:--";
          let tomorrowTime = p[i] !== false ? f_to_hms_str(p[i] + tp_offset) : "--:--:--";

          let isWhiteNight = false;
          if (t[6]) {
            if (i === 0 || i === 5) {
              isWhiteNight = true;
              result.hasWhiteNights = true;
            }
          }

          result.times.push({
            name: namazlar[i],
            today: todayTime,
            tomorrow: tomorrowTime,
            isWhiteNight: isWhiteNight,
            class: prayerClasses[i]
          });
        }

        return result;
      } catch (e) {
        console.error("Error in get_today:", e);
        return {error: "–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞–º–∞–∑–æ–≤"};
      }
    }

    // ==================== –ò–ù–¢–ï–†–§–ï–ô–°–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
    function validateInputs() {
      let isValid = true;

      document.querySelectorAll('.error').forEach(el => el.textContent = '');

      const latitude = parseFloat(document.getElementById('latitude').value);
      if (isNaN(latitude) || latitude < -90 || latitude > 90) {
        document.getElementById('latitudeError').textContent = '–®–∏—Ä–æ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç -90 –¥–æ 90';
        isValid = false;
      }

      const longitude = parseFloat(document.getElementById('longitude').value);
      if (isNaN(longitude) || longitude < -180 || longitude > 180) {
        document.getElementById('longitudeError').textContent = '–î–æ–ª–≥–æ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç -180 –¥–æ 180';
        isValid = false;
      }

      const timezone = parseFloat(document.getElementById('timezone').value);
      if (isNaN(timezone) || timezone < -12 || timezone > 14) {
        document.getElementById('timezoneError').textContent = '–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç -12 –¥–æ 14';
        isValid = false;
      }

      const angle1 = parseFloat(document.getElementById('angle1').value);
      if (isNaN(angle1) || angle1 < -90 || angle1 > 90) {
        document.getElementById('angle1Error').textContent = '–£–≥–æ–ª 1 –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç -90 –¥–æ 90';
        isValid = false;
      }

      const angle2 = parseFloat(document.getElementById('angle2').value);
      if (isNaN(angle2) || angle2 < -90 || angle2 > 90) {
        document.getElementById('angle2Error').textContent = '–£–≥–æ–ª 2 –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç -90 –¥–æ 90';
        isValid = false;
      }

      return isValid;
    }

    function updateCurrentDateTime() {
      const now = new Date();
      const dateOptions = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      };
      const timeOptions = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      };

      document.getElementById('currentDate').textContent = now.toLocaleDateString('ru-RU', dateOptions);
      document.getElementById('currentTime').textContent = now.toLocaleTimeString('ru-RU', timeOptions);
    }

    async function updatePrayerTimes() {
      if (!validateInputs()) {
        document.getElementById('prayerTimesTable').innerHTML = '<div class="error">–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø—Ä–∞–≤—å—Ç–µ –æ—à–∏–±–∫–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö</div>';
        return;
      }

      try {
        const latitude = document.getElementById('latitude').value;
        const longitude = document.getElementById('longitude').value;
        const time_zone = document.getElementById('timezone').value;
        const dst_element = document.querySelector('input[name="daylight"]:checked');
        const dst = dst_element ? dst_element.value : "0";
        const morning_twilight = document.getElementById('angle1').value;
        const evening_twilight = document.getElementById('angle2').value;

        document.getElementById('prayerTimesTable').innerHTML = '<div class="white-night">–†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞–º–∞–∑–æ–≤...</div>';

        const result = await get_today(latitude, longitude, time_zone, dst, morning_twilight, evening_twilight);

        if (result.error) {
          document.getElementById('prayerTimesTable').innerHTML = `<div class="error">${result.error}</div>`;
          return;
        }

        let tableHTML = `
          <table class="prayer-table">
            <thead>
              <tr>
                <th>–ù–∞–º–∞–∑</th>
                <th>–°–µ–≥–æ–¥–Ω—è (${result.date})</th>
                <th>–ó–∞–≤—Ç—Ä–∞</th>
              </tr>
            </thead>
            <tbody>
        `;

        result.times.forEach(prayer => {
          const todayClass = prayer.isWhiteNight ? 'white-night' : prayer.class;
          const tomorrowClass = prayer.isWhiteNight ? 'white-night' : prayer.class;

          tableHTML += `
            <tr>
              <td>${prayer.name}</td>
              <td class="${todayClass}">${prayer.today}</td>
              <td class="${tomorrowClass}">${prayer.tomorrow}</td>
            </tr>
          `;
        });

        tableHTML += `
            </tbody>
          </table>
        `;

        if (result.hasWhiteNights) {
          tableHTML += `<div class="white-night">${no_night}</div>`;
        }

        document.getElementById('prayerTimesTable').innerHTML = tableHTML;

      } catch (e) {
        console.error("Error in updatePrayerTimes:", e);
        document.getElementById('prayerTimesTable').innerHTML = '<div class="error">–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞–º–∞–∑–æ–≤</div>';
      }
    }

    async function calculateRelief() {
      const reliefResult = document.getElementById('reliefResult');

      reliefResult.style.display = 'block';
      reliefResult.textContent = "–ò–¥–µ—Ç —Ä–∞—Å—á–µ—Ç —Ä–µ–ª—å–µ—Ñ–∞...\n–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 10-20 —Å–µ–∫—É–Ω–¥.\n\n–ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤—ã—Å–æ—Ç...";

      try {
        const result = await calc_with_relief();
        reliefResult.textContent = result;
      } catch (error) {
        reliefResult.textContent = `–û—à–∏–±–∫–∞: ${error.message}\n\n–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–ª–∞–¥–∫–∏:\n${debugInfo}`;
      }
    }

    function showSettings() {
      document.getElementById('mainPage').style.display = 'none';
      document.getElementById('settingsPage').style.display = 'block';
      loadSettings();
    }

    function loadSettings() {
      const saved = localStorage.getItem('astroSettings');
      if (saved) {
        try {
          const settings = saved.split(';');
          if (settings.length >= 7) {
            document.getElementById('latitude').value = settings[0] || '';
            document.getElementById('longitude').value = settings[1] || '';
            document.getElementById('timezone').value = settings[2] || '0';

            if (settings[3] === '1') {
              document.getElementById('daylightYes').checked = true;
            } else {
              document.getElementById('daylightNo').checked = true;
            }

            document.getElementById('angle1').value = settings[4] || '18';
            document.getElementById('angle2').value = settings[5] || '17';

            if (settings[6] === '1') {
              document.getElementById('useWeather').checked = true;
              useWeatherData = true;
            } else {
              document.getElementById('useWeather').checked = false;
              useWeatherData = false;
            }
          }
        } catch (e) {
          console.error("Error loading settings:", e);
        }
      }
      updateCurrentDateTime();
      updatePrayerTimes();
    }

    function saveSettings() {
      if (!validateInputs()) {
        return;
      }

      try {
        const latitude = document.getElementById('latitude').value;
        const longitude = document.getElementById('longitude').value;
        const timezone = document.getElementById('timezone').value;
        const daylight = document.querySelector('input[name="daylight"]:checked')?.value || '0';
        const angle1 = document.getElementById('angle1').value;
        const angle2 = document.getElementById('angle2').value;
        const useWeather = document.getElementById('useWeather').checked ? '1' : '0';

        useWeatherData = document.getElementById('useWeather').checked;

        const settingsString = [latitude, longitude, timezone, daylight, angle1, angle2, useWeather].join(';');
        localStorage.setItem('astroSettings', settingsString);

        document.getElementById('settingsPage').style.display = 'none';
        document.getElementById('mainPage').style.display = 'block';
        updateCurrentDateTime();
        updatePrayerTimes();
      } catch (e) {
        console.error("Error saving settings:", e);
        alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫");
      }
    }

    function resetToDefault() {
      if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é?")) {
        document.getElementById('latitude').value = '';
        document.getElementById('longitude').value = '';
        document.getElementById('timezone').value = '0';
        document.getElementById('daylightNo').checked = true;
        document.getElementById('angle1').value = '18';
        document.getElementById('angle2').value = '17';
        document.getElementById('useWeather').checked = false;
        useWeatherData = false;

        document.querySelectorAll('.error').forEach(el => el.textContent = '');

        localStorage.removeItem('astroSettings');
        updateCurrentDateTime();
        updatePrayerTimes();
      }
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('mainPage').style.display = 'block';
      document.getElementById('settingsPage').style.display = 'none';
      document.getElementById('reliefResult').style.display = 'none';

      document.getElementById('useWeather').addEventListener('change', function() {
        useWeatherData = this.checked;
      });

      updateCurrentDateTime();
      loadSettings();

      setInterval(updateCurrentDateTime, 1000);
      setInterval(updatePrayerTimes, 360000);
    });
  </script>
</body>
</html>
